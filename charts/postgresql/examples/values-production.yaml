# PostgreSQL - Production Configuration
# Comprehensive production-ready configuration with all best practices

namespaceOverride: "production"

additionalLabels:
  environment: production
  tier: database

postgresql:
  database: "proddb"
  username: "produser"
  # Use external secret in production
  existingSecret: "postgresql-credentials"
  existingSecretPasswordKey: "password"
  existingPostgresSecret: "postgresql-credentials"
  existingPostgresPasswordKey: "postgres-password"

  image:
    repository: postgres
    tag: "16.4-alpine"
    pullPolicy: IfNotPresent

  config:
    # Performance tuning for production
    max_connections: "200"
    shared_buffers: "512MB"
    effective_cache_size: "2GB"
    maintenance_work_mem: "128MB"
    checkpoint_completion_target: "0.9"
    wal_buffers: "16MB"
    default_statistics_target: "100"
    random_page_cost: "1.1"
    effective_io_concurrency: "200"
    work_mem: "5MB"
    min_wal_size: "2GB"
    max_wal_size: "8GB"
    max_worker_processes: "8"
    max_parallel_workers_per_gather: "4"
    max_parallel_workers: "8"
    max_parallel_maintenance_workers: "4"

    # Logging
    log_min_duration_statement: "500"
    log_checkpoints: "on"
    log_connections: "on"
    log_disconnections: "on"
    log_lock_waits: "on"

  initScripts:
    01-extensions.sql: |
      CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
      CREATE EXTENSION IF NOT EXISTS pgcrypto;
      CREATE EXTENSION IF NOT EXISTS pg_trgm;

deployment:
  replicas: 1

  podAnnotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "9187"

  podSecurityContext:
    fsGroup: 999
    fsGroupChangePolicy: "OnRootMismatch"
    runAsNonRoot: true

  securityContext:
    runAsUser: 999
    runAsGroup: 999
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: false
    capabilities:
      drop:
        - ALL

  resources:
    limits:
      cpu: 2000m
      memory: 2Gi
    requests:
      cpu: 500m
      memory: 512Mi

  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app.kubernetes.io/name
                  operator: In
                  values:
                    - postgresql
            topologyKey: kubernetes.io/hostname

persistence:
  enabled: true
  storageClass: "fast-ssd"  # Use your storage class
  size: 100Gi
  accessModes:
    - ReadWriteOnce

service:
  enabled: true
  type: ClusterIP
  port: 5432

serviceAccount:
  create: true
  automountServiceAccountToken: false

pdb:
  enabled: true
  minAvailable: 1

networkPolicy:
  enabled: true
  ingress:
    - from:
      - namespaceSelector:
          matchLabels:
            name: production
      ports:
      - protocol: TCP
        port: 5432

backup:
  enabled: true
  schedule: "0 2 * * *"  # 2 AM daily
  retentionDays: 30
  successfulJobsHistoryLimit: 5
  failedJobsHistoryLimit: 3

  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 100m
      memory: 128Mi

  persistence:
    enabled: true
    storageClass: "standard"
    size: 200Gi

metrics:
  enabled: true

  resources:
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 50m
      memory: 64Mi

monitoring:
  enabled: true

  serviceMonitor:
    enabled: true
    interval: 30s
    scrapeTimeout: 10s
    labels:
      prometheus: kube-prometheus

  prometheusRule:
    enabled: true
    labels:
      prometheus: kube-prometheus

tls:
  enabled: false
  # Enable if you have cert-manager
  # certificate:
  #   enabled: true
  #   issuerRef:
  #     name: letsencrypt-prod
  #     kind: ClusterIssuer

vpa:
  enabled: false
  updateMode: "Auto"
